# ShitBC 0.3.0
참고: 이 문서에 누락된 내용이 있을 수 있습니다. 이 경우에는 ShitVM의 동작을 표준 동작으로 합니다.

## 자료형
ShitBC에서 다루는 모든 값에는 자료형이 있습니다. 자료형은 값의 특성, 크기 등을 나타냅니다. 자료형에 따라 연산 방법, 값이 메모리에서 차지하는 크기 등이 달라지므로 주의해야 합니다. ShitBC에서 기본적으로 제공하는 자료형의 종류는 다음과 같습니다.

|이름|번호|크기|설명|표현 범위|버전|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`int`|3|4|가장 기본적인 정수형입니다.|0\~4,294,967,295<br>-2,147,483,648\~2,147,483,647|0.1.0|
|`long`|4|8|크기가 큰 정수형입니다.|0\~18,446,744,073,709,551,615<br>-9,223,372,036,854,775,808\~9,223,372,036,854,775,807|0.1.0|
|`double`|6|8|가장 기본적인 실수형입니다.|유효숫자 15자리|0.1.0|
|`pointer`|7||메모리 주소를 나타내는 포인터입니다.|OS에 따라 다름|0.2.0|
|`gcpointer`|8||GC에 의해 관리되는 메모리 주소를 나타내는 포인터입니다.|OS에 따라 다름|0.3.0|

ShitBC에서 정수형은 기본적으로 부호 없이 처리됩니다. 따라서 부호의 여부에 영향을 받는 일부 동작들은 부호를 구분하는 니모닉과 구분하지 않는 니모닉으로 나뉘어 있습니다. 또, 정수형은 2의 보수법, 실수형은 IEE754에 따라 구현됩니다.

포인터는 운영체제에 따라 크기가 달라지는데, 일반적으로 32비트 운영체제에서는 4바이트, 64비트 운영체제에서는 8바이트이며, 표현 범위는 크기에 따라 `int`, `long` 자료형의 표현 범위와 같습니다. `pointer`와 `gcpointer`는 둘 다 본질적으로는 포인터이나, `gcpointer`는 GC에 의해 관리되는 메모리 주소만 저장할 수 있다는 제약이 있습니다.

ShitVM은 자료형의 정보가 값의 앞에 저장되므로 실제로 메모리에 할당되는 크기는 위 표에서 나타낸 것보다 더 클 수 있습니다.

### 구조체
기본 제공 자료형을 여러 개 묶어 1개의 자료형처럼 다룰 수 있는데, 이렇게 만든 새로운 자료형을 구조체라고 합니다. 0.2.0부터 사용할 수 있으며, 다른 구조체를 묶을 수도 있습니다. 이때 구조체에 묶여 있는 값을 필드라고 합니다. 구조체의 번호는 10부터 순서대로 할당되며, 필드의 번호는 0부터 순서대로 할당됩니다.

구조체의 최소 크기는 필드의 크기의 총 합인데, ShitBC가 구동되는 환경에 따라 패딩이 포함될 수 있어 실제 크기는 환경에 따라 다릅니다.

`push` 니모닉을 사용해 구조체를 스택에 추가할 때에는 `(자료형 번호) - 10 + (상수의 개수)`를 피연산자로 하면 됩니다.

## 함수
명령어의 집합을 함수라고 합니다. 함수는 0개 이상의 매개 변수를 가질 수도 있고, 반환 값이 있을 수도 있습니다. 함수의 번호는 0부터 순서대로 할당되며, 각각의 매개 변수의 번호는 0부터 순서대로 할당되며 지역 변수로 취급됩니다.

함수는 반드시 1개 이상의 명령어를 가져야하며, 종료될 때는 반드시 `ret` 니모닉을 사용해 종료되어야 합니다. 또, 함수의 가장 첫번째 명령어를 함수의 진입점이라고 합니다.

특정한 명령어에 레이블을 할당할 수도 있습니다. 레이블의 번호는 0부터 순서대로 할당됩니다.

### 진입점
프로그램이 실행되면 ShitBC 구현체는 가장 먼저 진입점에 있는 명령어들을 실행합니다. 진입점은 함수로 보지 않으므로 매개 변수, 반환 값을 가질 수 없으며, 반드시 `ret` 니모닉을 사용해 종료될 필요는 없습니다. 하지만 레이블을 가질 수는 있습니다.

## 스택
ShitBC는 구현체가 스택 기반 가상머신임을 상정하고 만들어졌습니다. 구현체가 실제로 스택 기반일 필요는 없으나, 스택 기반 가상머신인 것처럼 에뮬레이션 할 수 있어야 합니다.

스택은 여러 개의 스택 프레임으로 나눠지는데, 함수가 호출될 때마다 새 스택 프레임이 만들어집니다. 매개 변수에 접근하는 경우를 제외하면 스택 프레임의 바깥쪽은 접근할 수 없습니다.

### 지역 변수
지역 변수는 스택에 저장되는데, 지역 변수 목록에 지역 변수에 대응되는 스택의 주소가 저장됩니다. 지역 변수 번호는 0부터 순서대로 할당되나, 매개 변수가 있을 경우에는 매개 변수 다음에 할당됩니다.

## 힙
스택은 함수가 종료되면 저장된 데이터가 유효해지지 않고, 크기가 제한적이므로 ShitBC 구현체는 스택 외에도 힙을 제공합니다. 힙은 실행 환경의 한계가 있지 않는 이상 프로그램에서 요청하는 크기만큼의 메모리 영역을 제공할 수 있습니다.

힙은 2개의 영역으로 나누어지는데, 관리되는 영역과 관리되지 않는 영역입니다.

### 관리되는 영역
관리되는 영역은 할당된 메모리 영역을 GC에 의해 관리하는 영역입니다. 프로그램이 더 이상 특정한 메모리 영역을 사용하지 않으면 자동으로 GC가 해당 영역의 할당을 해제하지만, 할당 속도가 관리되지 않는 영역에 비해 상대적으로 느리고, 메모리 상태에 따라 GC가 발생하면 시스템 성능에 따라 프로그램이 일시 중단될 수 있습니다.

### 관리되지 않는 영역
관리되지 않는 영역은 프로그램이 힙에 메모리 영역을 할당받을 때 최대한의 속도를 내기위해 존재합니다. 할당 속도는 빠르지만 관리되지 않기 때문에 사용을 마친 메모리 영역은 반드시 프로그램이 직접 할당을 해제해야 합니다. 그렇지 않으면 메모리 누수가 발생할 수 있습니다.

## 명령어
기본적으로 명령어는 1바이트의 크기를 갖습니다. 이는 명령어의 니모닉을 나타냅니다. 일부 피연산자를 필요로 하는 명령어는 4바이트의 피연산자를 그 뒤에 덧붙여 총 5바이트의 크기를 갖습니다. 피연산자는 Little 엔디안으로 저장됩니다.

니모닉은 크게 7가지 카테고리로 분류할 수 있습니다.
- 스택 관리 니모닉
- 형 변환 니모닉
- 메모리 관리 니모닉
- 산술 연산 니모닉
- 비트 연산 니모닉
- 비교 연산 니모닉
- 분기 니모닉

### 스택 관리 니모닉
스택을 관리하는 니모닉입니다.
- `push`
- `pop`
- `load`
- `store`
- `lea`
- `flea`
- `tload`
- `tstore`
- `copy`
- `swap`

#### `push`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x01|상수 번호|0.1.0|

스택의 가장 위에 상수 또는 구조체를 추가합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `CONSTANTPOOL_OUTOFRANGE`

#### `pop`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x02||0.1.0|

스택의 가장 위에 있는 값을 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`

#### `load`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x03|지역 변수 번호|0.1.0|

지역 변수에 저장된 값을 스택의 가장 위에 복사합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `LOCALVARIABLE_OUTOFRANGE`

#### `store`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x04|지역 변수 번호|0.1.0|

지역 변수 번호가 유효할 경우 스택의 가장 위에 있는 값을 지역 변수에 이동시킵니다. 지역 변수 번호가 유효하지 않으나 사용할 수 있는 번호일 경우 스택의 가장 위를 지역 변수로 설정합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `LOCALVARIABLE_INVALIDINDEX`

#### `lea`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x05|지역 변수 번호|0.2.0|

지역 변수를 가리키는 포인터를 스택의 가장 위에 추가합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `LOCALVARIABLE_OUTOFRANGE`

#### `flea`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x06|필드 번호|0.2.0|

필드를 가리키는 포인터를 스택의 가장 위에 추가합니다. 이 명령어가 실행될 때 스택의 가장 위에 구조체 포인터가 있어야 하는데, 해당 구조체 포인터가 가리키고 있는 구조체의 필드를 가리키는 포인터를 추가합니다. 새 포인터를 추가하기 전 구조체 포인터는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `STACK_EMPTY`
- `POINTER_NULLPOINTER`
- `STRUCTURE_FILED_OUTOFRANGE`
- `STRUCTURE_NOTSTRUCTURE`

#### `tload`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x07||0.2.0|

포인터가 가리키고 있는 곳에 있는 값을 스택의 가장 위에 복사합니다. 이 명령어가 실행될 때 스택의 가장 위에 포인터가 있어야 합니다. 값을 복사하기 전 해당 포인터는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `STACK_EMPTY`
- `POINTER_NULLPOINTER`
- `POINTER_NOTPOINTER`

#### `tstore`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x08||0.2.0|

스택의 가장 위에 있는 값을 포인터가 가리키고 있는 곳에 복사합니다. 이 명령어가 실행될 때 스택의 가장 위의 아래에 포인터가 있어야 하는데, 스택의 가장 위에 있는 값을 스택의 가장 위의 아래에 있는 포인터가 가리키는 곳에 복사합니다. 복사할 값과 포인터가 가리키는 곳에 이미 저장되어 있는 값의 자료형이 반드시 같아야 합니다. 값을 복사한 후 두 값은 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_NULLPOINTER`
- `POINTER_NOTPOINTER`

#### `copy`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x09||0.2.0|

스택의 가장 위에 있는 값을 그 위에 복사합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_OVERFLOW`

#### `swap`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0A||0.2.0|

스택의 가장 위에 있는 값과 그 아래에 있는 값을 서로 바꿉니다. 두 값의 자료형이 반드시 같아야 합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`

### 형 변환 니모닉
스택에 있는 값의 자료형을 바꾸는 니모닉입니다.
- `toi`
- `tol`
- `tod`
- `top`

#### `toi`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x2B *(0.3.0~)*<br>0x29 *(0.2.0)*<br>0x23 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값의 자료형을 `int`로 형 변환합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_OVERFLOW`

#### `tol`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x2C *(0.3.0~)*<br>0x2A *(0.2.0)*<br>0x24 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값의 자료형을 `long`으로 형 변환합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_OVERFLOW`

#### `tod`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x2E *(0.3.0~)*<br>0x2B *(0.2.0)*<br>0x25 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값의 자료형을 `double`로 형 변환합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_OVERFLOW`

#### `top`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x2F *(0.3.0~)*<br>0x2C *(0.2.0)*<br>0x26 *(0.1.0)*||0.2.0|

스택의 가장 위에 있는 값의 자료형을 `pointer`로 형 변환합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_OVERFLOW`

### 메모리 관리 니모닉
메모리를 관리하는 니모닉입니다.
- `null`
- `new`
- `delete`
- `gcnull`
- `gcnew`

#### `null`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x30||0.3.0|

스택의 가장 위에 pointer 자료형의 널포인터를 추가합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`

#### `new`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x31|자료형 번호|0.3.0|

힙에 수동으로 할당 해제하지 않으면 해제되지 않는 메모리 영역을 할당받은 뒤, 그 메모리 영역의 가장 첫번째 공간을 가리키는 포인터를 스택의 가장 위에 추가합니다. 할당된 메모리 영역의 크기는 최소 자료형의 크기임이 보장됩니다. 할당이 실패할 경우 널포인터를 스택의 가장 위에 추가합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `TYPE_OUTOFRANGE`

#### `delete`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x32||0.3.0|

포인터가 가리키는 메모리 영역을 할당 해제합니다. 해당 메모리 영역은 반드시 `new` 니모닉을 사용해 할당된 공간이여야 합니다. 널포인터일 경우 아무 동작도 실행하지 않습니다. 포인터가 잘못된 메모리 영역을 가리킬 경우의 동작은 정의되지 않습니다. 할당 해제하기 전 포인터는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `POINTER_NOTPOINTER`

ShitVM에서는 포인터가 잘못된 메모리 영역을 가리킬 경우 `POINTER_UNKNOWNADDRESS` 예외가 발생합니다.

#### `gcnull`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x33||0.3.0|

스택의 가장 위에 gcpointer 자료형의 널포인터를 추가합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`

#### `gcnew`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x34|자료형 번호|0.3.0|

힙에 GC에 의해 자동으로 관리되는 메모리 영역을 할당받은 뒤, 그 메모리 영역의 가장 첫번째 공간을 가리키는 포인터를 스택의 가장 위에 추가합니다. 할당된 메모리 영역의 크기는 최소 자료형의 크기임이 보장됩니다. 할당이 실패할 경우 널포인터를 스택의 가장 위에 추가합니다. 메모리 상태에 따라 GC가 발생한 후 메모리 영역이 할당될 수 있습니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `TYPE_OUTOFRANGE`

### 산술 연산 니모닉
스택의 두 값에 대해 산술 연산을 하는 니모닉입니다.
- `add`
- `sub`
- `mul`
- `imul`
- `div`
- `idiv`
- `mod`
- `imod`
- `neg`
- `inc`
- `dec`

#### `add`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0B *(0.2.0~)*<br>0x05 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 더한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `sub`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0C *(0.2.0~)*<br>0x06 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값을 그 아래에 있는 값에서 뺀 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `mul`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0D *(0.2.0~)*<br>0x07 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 곱한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `imul`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0E *(0.2.0~)*<br>0x08 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 곱한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `div`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x0F *(0.2.0~)*<br>0x09 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값으로 그 아래에 있는 값을 나눈 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `ARITHMETIC_DIVIDEBYZERO`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `idiv`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x10 *(0.2.0~)*<br>0x0A *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값으로 그 아래에 있는 값을 나눈 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `ARITHMETIC_DIVIDEBYZERO`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `mod`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x11 *(0.2.0~)*<br>0x0B *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값으로 그 아래에 있는 값을 나눈 나머지를 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `ARITHMETIC_DIVIDEBYZERO`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `imod`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x12 *(0.2.0~)*<br>0x0C *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값으로 그 아래에 있는 값을 나눈 나머지를 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `ARITHMETIC_DIVIDEBYZERO`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `neg`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x13 *(0.2.0~)*<br>0x0D *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값의 부호를 바꿉니다. 포인터와 구조체에 대해서는 연산할 수 없습니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `inc`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x14 *(0.2.0~)*<br>0x0E *(0.1.0)*||0.1.0|

포인터가 가리키고 있는 곳에 있는 값에 1을 더합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 연산 후 포인터는 스택에서 삭제됩니다. *(0.2.0~)*

스택의 가장 위에 있는 값에 1을 더합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. *(0.1.0)*

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `POINTER_NULLPOINTER`
- `POINTER_NOTPOINTER`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `dec`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x15 *(0.2.0~)*<br>0x0F *(0.1.0)*||0.1.0|

포인터가 가리키고 있는 곳에 있는 값에 -1을 더합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 연산 후 포인터는 스택에서 삭제됩니다. *(0.2.0~)*

스택의 가장 위에 있는 값에 -1을 더합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. *(0.1.0)*

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `POINTER_NULLPOINTER`
- `POINTER_NOTPOINTER`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

### 비트 연산 니모닉
스택의 두 값에 대해 비트 연산을 하는 니모닉입니다.
- `and`
- `or`
- `xor`
- `not`
- `shl`
- `sal`
- `shr`
- `sar`

#### `and`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x16 *(0.2.0~)*<br>0x10 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 비트 단위 논리곱 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `or`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x17 *(0.2.0~)*<br>0x11 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 비트 단위 논리합 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `xor`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x18 *(0.2.0~)*<br>0x12 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값과 그 아래에 있는 두 값을 비트 단위 배타적 논리합 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `not`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x19 *(0.2.0~)*<br>0x13 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값의 비트를 반전합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `shl`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1A *(0.2.0~)*<br>0x14 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값만큼 그 아래에 있는 값을 비트 왼쪽 시프트 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다. `sal` 니모닉과 같습니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `sal`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1B *(0.2.0~)*<br>0x15 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값만큼 그 아래에 있는 값을 비트 왼쪽 시프트 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다. `shl` 니모닉과 같습니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `shr`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1C *(0.2.0~)*<br>0x16 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값만큼 그 아래에 있는 값을 비트 오른쪽 시프트 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `sar`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1D *(0.2.0~)*<br>0x17 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값만큼 그 아래에 있는 값을 비트 오른쪽 시프트 연산한 뒤 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 포인터와 구조체에 대해서는 연산할 수 없습니다. 값을 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `POINTER_INVALIDFORPOINTER`
- `STRUCTURE_INVALIDFORSTRUCTURE`

### 비교 연산 니모닉
스택의 두 값에 대해 비교 연산을 하는 니모닉입니다.
- `cmp`
- `icmp`

#### `cmp`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1E *(0.2.0~)*<br>0x18 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값(B)과 그 아래에 있는 두 값(A)을 비교한 뒤 대소관계를 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 구조체에 대해서는 연산할 수 없습니다. 결과를 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 없는 연산입니다.

|조건|값|자료형|
|:-:|:-:|:-:|
|`A > B`|1|`int`|
|`A == B`|0|`int`|
|`A < B`|-1|`int`|

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `STRUCTURE_INVALIDFORSTRUCTURE`

#### `icmp`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x1F *(0.2.0~)*<br>0x19 *(0.1.0)*||0.1.0|

스택의 가장 위에 있는 값(B)과 그 아래에 있는 두 값(A)을 비교한 뒤 대소관계를 스택의 가장 위에 추가합니다. 두 값의 자료형이 반드시 같아야 합니다. 구조체에 대해서는 연산할 수 없습니다. 결과를 추가하기 전 연산의 두 피연산자는 스택에서 삭제됩니다. 부호 있는 연산입니다.

|조건|값|자료형|
|:-:|:-:|:-:|
|`A > B`|1|`int`|
|`A == B`|0|`int`|
|`A < B`|-1|`int`|

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `STACK_DIFFERENTTYPE`
- `STRUCTURE_INVALIDFORSTRUCTURE`

### 분기 니모닉
명령어의 실행 흐름을 제어하는 니모닉입니다.
- `jmp`
- `je`
- `jne`
- `ja`
- `jae`
- `jb`
- `jbe`
- `call`
- `ret`

#### `jmp`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x20 *(0.2.0~)*<br>0x1A *(0.1.0)*|레이블 번호|0.1.0|

다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정합니다.

다음 예외가 발생할 수 있습니다.
- `LABEL_OUTOFRANGE`

#### `je`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x21 *(0.2.0~)*<br>0x1B *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 0일 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `je`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x22 *(0.2.0~)*<br>0x1C *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 0이 아닐 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `ja`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x23 *(0.2.0~)*<br>0x1D *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 1일 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `jae`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x24 *(0.2.0~)*<br>0x1E *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 -1이 아닐 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `jb`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x25 *(0.2.0~)*<br>0x1F *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 -1일 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `jbe`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x26 *(0.2.0~)*<br>0x20 *(0.1.0)*|레이블 번호|0.1.0|

스택의 가장 위에 있는 값이 1이 아닐 경우 다음에 실행할 명령어를 레이블이 가리키는 명령어로 설정한 뒤 그 값을 스택에서 삭제합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `LABEL_OUTOFRANGE`

#### `call`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x27 *(0.2.0~)*<br>0x21 *(0.1.0)*|함수 번호|0.1.0|

스택 프레임과 지역 변수 목록을 초기화하고, 매개 변수를 지역 변수 목록에 추가한 뒤, 다음에 실행할 명령어를 함수의 진입점으로 설정합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_OVERFLOW`
- `STACK_EMPTY`
- `FUNCTION_OUTOFRANGE`

#### `ret`
|옵코드|피연산자|버전|
|:-:|:-:|:-:|
|0x28 *(0.2.0~)*<br>0x22 *(0.1.0)*|함수 번호|0.1.0|

스택 프레임과 지역 변수 목록을 복원하고, 반환 값이 있을 경우 반환 값을 스택의 가장 위로 이동시킨 뒤, 다음에 실행할 명령어를 호출자의 다음 명령어로 설정합니다.

다음 예외가 발생할 수 있습니다.
- `STACK_EMPTY`
- `FUNCTION_TOPOFCALLSTACK`

## 예외
예외는 크게 8가지 카테고리로 분류할 수 있습니다.
- 스택 관련 예외
- 상수 풀 관련 예외
- 산술 연산 관련 예외
- 지역 변수 관련 예외
- 레이블 관련 예외
- 함수 관련 예외
- 포인터 관련 예외
- 구조체 관련 예외

### 스택 관련 예외
- `STACK_OVERFLOW`<br>스택에 공간이 없습니다.
- `STACK_EMPTY`<br>스택이 비어있습니다.
- `STACK_DIFFERENTTYPE`<br>두 피연산자의 자료형이 다릅니다.

### 상수 풀 관련 예외
- `CONSTANTPOOL_OUTOFRANGE`<br>범위를 벗어난 상수 번호입니다.

### 산술 연산 관련 예외
- `ARITHMETIC_DIVIDEBYZERO`<br>0으로 나눌 수 없습니다.

### 지역 변수 관련 예외
- `LOCALVARIABLE_OUTOFRANGE`<br>범위를 벗어난 지역 변수 번호입니다.
- `LOCALVARIABLE_INVALIDINDEX`<br>유효하지 않은 지역 변수 번호입니다.

### 레이블 관련 예외
- `LABEL_OUTOFRANGE`<br>범위를 벗어난 레이블 번호입니다.

### 함수 관련 예외
- `FUNCTION_OUTOFRANGE`<br>범위를 벗어난 함수 번호입니다.
- `FUNCTION_NORETINSTRUCTION`<br>함수가 `ret` 명령어 없이 종료되었습니다.

### 포인터 관련 예외
- `POINTER_NULLPOINTER`<br>널포인터를 역참조할 수 없습니다.
- `POINTER_NOTPOINTER`<br>피연산자의 자료형이 포인터가 아닙니다.
- `POINTER_INVALIDFORPOINTER`<br>피연산자가 포인터일 수 없습니다.

### 구조체 관련 예외
- `STRUCTURE_FILED_OUTOFRANGE`<br>범위를 벗어난 필드 번호입니다.
- `STRUCTURE_NOTSTRUCTURE`<br>피연산자의 자료형이 구조체가 아닙니다.
- `STRUCTURE_INVALIDFORSTRUCTURE`<br>피연산자가 구조체일 수 없습니다.